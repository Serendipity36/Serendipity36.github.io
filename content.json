{"meta":{"title":"Serendipity's blogs","subtitle":"","description":"","author":"Serendipity","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-08-04T02:16:53.000Z","updated":"2020-08-04T02:17:01.944Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-08-04T02:17:14.000Z","updated":"2020-08-04T02:17:26.130Z","comments":true,"path":"contact/index.html","permalink":"http://yoursite.com/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-08-04T02:16:29.000Z","updated":"2020-08-04T02:16:44.736Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"404","date":"2018-08-04T02:20:30.000Z","updated":"2020-08-04T02:21:03.246Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"categories","date":"2020-08-04T02:15:52.000Z","updated":"2020-08-04T02:16:18.407Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringCloud之服务网关（尚硅谷）","slug":"SpringCloud之服务网关（尚硅谷）","date":"2020-08-03T03:01:49.000Z","updated":"2020-08-04T01:36:37.989Z","comments":true,"path":"2020/08/03/SpringCloud之服务网关（尚硅谷）/","link":"","permalink":"http://yoursite.com/2020/08/03/SpringCloud%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%EF%BC%88%E5%B0%9A%E7%A1%85%E8%B0%B7%EF%BC%89/","excerpt":"","text":"Gateway新一代网关什么是Gateway网关？1.Gateway是在Spring生态系统之上构建的API网关服务,基于Spring 5,Spring Boot 2和Project Reactor等技术。 2.Gateway旨在提供一 种简单而有效的方式来对API进行路由，以吸提供- 些强大的过滤器功能， 例如:熔断、限流、重试等 3.SpringCloud Gateway是Spring Cloud的一个全新项目,纡Spring 5.0+ Spring Boot 2.0和Project Reactor等技术开发的网关,它旨在为微服务架构提供一种简单有效的统一 的API路由管理方式。 4.SpringCloud Gateway作为Spring Cloud生态系统中的网关，目标是替代Zuul,在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 1.x非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty 5.SpringCloud Gateway的目标提供统一的路由方式且基 于Filter 链的方式提供了网关基本的功能，例如:安全，监控/指标, 和限流。 SpringCloud Gateway的特性1.基于Spring Framework 5, Project Reactor和Spring Boot 2.0进行构建; 2.动态路由:能够匹配任何请求属性; 3.可以对路由指定Predicate (断言)和Filter (过滤器) ; 4.集成Hystrix的断路器功能; 5.集成Spring Cloud服务发现功能; 6.易于编写的Predicate (断言)和Filter (过滤器) ; 7.请求限流功能; 8.支持路径重写。 Gateway三大核心概念 Route路由：路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由。 Predicate断言：参考的是java8的java.util.function.Predicate。开发人员可以匹配HTTP请求中的所有内容（例如请求头或请求参数），如果请求与断言相匹配则进行路由。 Filter过滤：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。 web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后，进行一些精细化控制。 predicate就是我们的匹配条件；而filter，就可以理解为一个无所不能的拦截器。而有了这两个元素，再加上目标uri，就可以实现一个具体的路由了。 Gateway工作流程 核心逻辑：路由转发+执行过滤器链 入门配置1.新建module：cloud-gateway-gateway9527 2.改pom文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;parent> &lt;artifactId>cloud2020&lt;/artifactId> &lt;groupId>com.sunqs.springcloud&lt;/groupId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;/parent> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;artifactId>cloud-gateway-gateway9527&lt;/artifactId> &lt;dependencies> &lt;!--gateway--> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-gateway&lt;/artifactId> &lt;/dependency> &lt;!--eureka client--> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId> &lt;/dependency> &lt;!--引入自定义的api通用包，可使用Payment支付Entity--> &lt;dependency> &lt;groupId>com.aiguigu.springcloud&lt;/groupId> &lt;artifactId>cloud-api-commons&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;scope>compile&lt;/scope> &lt;/dependency> &lt;!--一般基础配置类--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-devtools&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;optional>true&lt;/optional> &lt;/dependency> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;optional>true&lt;/optional> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/project> 3.写yml server: port: 9527 spring: application: name: cloud-gateway cloud: gateway: routes: - id: payment_routh #payment_routh #路由的ID，没有固定规则但要求唯一，简易配合服务名 uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** #断言，路径相匹配的进行路由 - id: payment_routh2 #payment_routh #路由的ID，没有固定规则但要求唯一，简易配合服务名 uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/lb/** #断言，路径相匹配的进行路由 eureka: instance: hostname: cloud-gateway-service client: service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka 4.业务类：无 5.主启动类：GateWayMain9527 @SpringBootApplication @EnableEurekaClient public class GateWayMain9527 &amp;#123; public static void main(String[] args) &amp;#123; SpringApplication.run(GateWayMain9527.class,args); &amp;#125; &amp;#125; 6.测试：http://localhost:8001/payment/get/31与http://localhost:9527/payment/get/31 都可以访问到。 7:gateway网关路由有两种配置方式 在配置文件yml中配置； 代码中注入RouteLocator的Bean： @Configuration public class GatewayConfig &amp;#123; @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder)&amp;#123; RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes(); routes.route(\"path_route_atguigu\", r -> r.path(\"/guonei\") .uri(\"http://news.baidu.com/guonei\")).build(); return routes.build(); &amp;#125; &amp;#125; 如果要访问 http://news.baidu.com/guonei 这个网站,配置路由规则为http://localhost:9527/guonei就可以访问到 通过微服务名实现动态路由 pom文件修改如下 server: port: 9527 spring: application: name: cloud-gateway cloud: gateway: discovery: locator: enabled: true #开启从注册中心动态动态创建路由的功能,利用微服务名进行路由 routes: - id: payment_routh #payment_routh #路由的ID，没有固定规则但要求唯一，简易配合服务名 uri: lb://cloud-payment-service # uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** #断言，路径相匹配的进行路由 - id: payment_routh2 #payment_routh #路由的ID，没有固定规则但要求唯一，简易配合服务名 uri: lb://cloud-payment-service # uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/lb/** #断言，路径相匹配的进行路由 eureka: instance: hostname: cloud-gateway-service client: fetch-registry: true register-with-eureka: true service-url: #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址 # defaultZone: http://eureka7002.com:7002/eureka/ # 单机版eureka defaultZone: http://eureka7001.com:7001/eureka/ Predicate的使用常用的Route Predicate After Route Predicate：- After=2020-08-04T08:54:04.768+08:00[Asia/Shanghai] Before Route Predicate：- Before=2020-08-04T08:54:04.768+08:00[Asia/Shanghai] Between Route Predicate：- Between=2020-08-04T08:54:04.768+08:00[Asia/Shanghai],2020-09-04T08:54:04.768+08:00[Asia/Shanghai] Cookie Route Predicate：- Cookie=username,zzyy Header Route Predicate：- Header=X-Request-Id,\\d+ Host Route Predicate Method Route Predicate Path Route Predicate Query Route Predicate 时间断言格式的获取public static void main(String[] args) &amp;#123; ZonedDateTime zdt = ZonedDateTime.now(); System.out.println(zdt); &amp;#125; 2020-08-04T08:54:04.768+08:00[Asia/Shanghai] 总结Predicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理。 Filter的使用Gateway Filter是什么路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。 Spring Cloud Gateway 内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生。 生命周期：pre，post 种类：GatewayFilter(31种),GlobalFilter(十种) 自定义过滤器1.创建Gateway配置类 @Configuration @Slf4j @Order(0) public class MyLogGatewayFilter implements GlobalFilter, Ordered &amp;#123; @Override public Mono&lt;Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) &amp;#123; log.info(\"******come in MyLogGatewayFilter: \" + new Date()); String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\"); if (uname == null) &amp;#123; log.info(\"******用户名为null，非法用户，😿\"); exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE); return exchange.getResponse().setComplete(); &amp;#125; return chain.filter(exchange); &amp;#125; @Override public int getOrder() &amp;#123; return 0; &amp;#125; &amp;#125; // @Override 实现上面@Order(0)注解就可以不用实现接口 // public int getOrder() &amp;#123; // return 0; // &amp;#125; 可以写多个Filter进行过滤，传回过滤链就行。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-08-03T02:57:46.437Z","updated":"2020-08-03T02:57:46.437Z","comments":true,"path":"2020/08/03/hello-world/","link":"","permalink":"http://yoursite.com/2020/08/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}