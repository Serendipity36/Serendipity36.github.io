{"meta":{"title":"Serendipity's blogs","subtitle":"Serendipity","description":"","author":"Serendipity","url":"https://serendipity36.github.io","root":"/"},"pages":[{"title":"404","date":"2018-08-04T02:20:30.000Z","updated":"2020-08-04T02:21:03.246Z","comments":true,"path":"404.html","permalink":"https://serendipity36.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2020-08-04T02:16:53.000Z","updated":"2020-08-04T02:17:01.944Z","comments":true,"path":"about/index.html","permalink":"https://serendipity36.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-08-04T02:15:52.000Z","updated":"2020-08-04T02:16:18.407Z","comments":true,"path":"categories/index.html","permalink":"https://serendipity36.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-08-04T02:17:14.000Z","updated":"2020-08-04T02:17:26.130Z","comments":true,"path":"contact/index.html","permalink":"https://serendipity36.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-08-04T02:16:29.000Z","updated":"2020-08-04T02:16:44.736Z","comments":true,"path":"tags/index.html","permalink":"https://serendipity36.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringCloud之消息驱动(尚硅谷)","slug":"SpringCloud之消息驱动-尚硅谷","date":"2020-08-05T05:36:06.000Z","updated":"2020-08-05T09:20:40.887Z","comments":true,"path":"2020/08/05/SpringCloud之消息驱动-尚硅谷/","link":"","permalink":"https://serendipity36.github.io/2020/08/05/SpringCloud%E4%B9%8B%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8-%E5%B0%9A%E7%A1%85%E8%B0%B7/","excerpt":"","text":"SpringCloud Stream 消息驱动消息驱动概述 屏蔽底层消息中间件差异，降低切换成本，统一消息的编程模型 什么是SpringCloudStream 官方定义SpringCloud Stream是一个构建消息驱动微服务的框架。 应用程序通过inputs和outputs来与SpringCloudStream中的binder对象交互。 通过我们配置来binding(绑定)，而SpringCloud Stream的binder对象负责与消息中间件交互。 设计思想 在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行信息交互的时候，由于各消息中间件构建的初衷不同，他们的实现细节上会有较大的差异性。 通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件之间的隔离。 通过向应用程序暴露统一的Channal通道，使得应用程序不需要再考虑各种不同的消息中间件实现。 通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。 编码API和常用注解 编码实现1.RabbitMQ环境准备 2.工程中新建三个子模块 Cloud-stream-rabbitmq-provider8801作为生产者进行发消息模块 cloud-stream-rabbitmq-consumer8802作为消息接收模块 cloud-stream-rabbitmq-consumer8803作为消息接收模块","categories":[{"name":"SpringCloud学习","slug":"SpringCloud学习","permalink":"https://serendipity36.github.io/categories/SpringCloud%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Mac切换homebrew镜像源","slug":"Mac切换homebrew镜像源","date":"2020-08-05T01:39:18.000Z","updated":"2020-08-05T01:44:07.043Z","comments":true,"path":"2020/08/05/Mac切换homebrew镜像源/","link":"","permalink":"https://serendipity36.github.io/2020/08/05/Mac%E5%88%87%E6%8D%A2homebrew%E9%95%9C%E5%83%8F%E6%BA%90/","excerpt":"","text":"切换清华镜像源： vim ~/.bash_profile echo \"export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles\" >> ~/.bash_profile source ~/.bash_profile # 使刚才的配置立即生效 homebrew常用的命令： brew -v brew update --verbose #观察update过程 brew info demo #查看demo包的信息 Brew tap xxx 添加源 brew update #更新自己的Homebrew brew search demo #寻找包名含有demo的包 brew doctor #检查brew的运行状态 brew outdates #检查本机内已经处于旧版本的包 brew list #列出brew安装的包 brew cleanup #清理缓存 brew install demo #安装demo包 brew uninstall demo #卸载demo包 brew link demo #关联demo包 php -m | grep phalcon #检测扩展 brew -S phalcon #找到对应版本的phalcon扩展 #修改homebrew镜像源: #国内清华大学 echo \"export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles\" >> ~/.bash_profile #中科大源 echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles' >> ~/.bash_profile #立即生效 source ~/.bash_profile","categories":[],"tags":[]},{"title":"Mac安装RabbitMQ","slug":"Mac安装RabbitMQ","date":"2020-08-05T01:17:08.000Z","updated":"2020-08-05T09:36:50.300Z","comments":true,"path":"2020/08/05/Mac安装RabbitMQ/","link":"","permalink":"https://serendipity36.github.io/2020/08/05/Mac%E5%AE%89%E8%A3%85RabbitMQ/","excerpt":"","text":"安装命令 brew install rabbitmq 启动RabbitMQ cd /usr/local/Cellar/rabbitmq/3.8.3/sbin sudo ./rabbitmq-server 启动成功如图 浏览器输入http://127.0.0.1:15672 用户名：guest 密码：guest 登陆成功如图： 关闭RabbitMQ sudo ./rabbitmqctl stop","categories":[],"tags":[]},{"title":"SpringCloud之消息总线（尚硅谷）","slug":"SpringCloud之消息总线(尚硅谷)","date":"2020-08-04T08:48:30.000Z","updated":"2020-08-05T09:29:54.281Z","comments":true,"path":"2020/08/04/SpringCloud之消息总线(尚硅谷)/","link":"","permalink":"https://serendipity36.github.io/2020/08/04/SpringCloud%E4%B9%8B%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF(%E5%B0%9A%E7%A1%85%E8%B0%B7)/","excerpt":"","text":"SpringCloud Bus 消息总线概述什么是SpringCloud Bus 消息总线 在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在总线上的各个实例，都可以方便的广播一些需要让其他连接在该主题上的实例都知道的消息。 基本原理 ConfigClient 实例都监听MQ中同一个topic（默认是springcloubus），当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其他监听统一topic的服务就能得到通知，然后去更新自身的配置。 SpringCloud Bus动态刷新全局广播1.先在本机配置好RabbitMQ环境并启动 2.演示广播效果，增加复杂度，以3355为模板创建Module：cloud-config-client3366 3.设计思想： 1）利用消息总线触发一个客户端/bus/refresh，而刷新所有客户端的配置。 2）利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置。 2）的设计思想更加适合，1）不适合的理由如下 打破了微服务的职责单一性，因为微服务本身是一个业务模块，它本不应该承担配置刷新的职责。 破坏了微服务各节点的对等性。 有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改 4.给cloud-config-center3344配置中心服务端添加消息总线支持 pom文件添加 &lt;!--添加消息总线RabbitMQ支持--> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-bus-amqp&lt;/artifactId> &lt;/dependency> 修改yml文件： server: port: 3344 spring: application: name: cloud-config-center cloud: config: server: git: uri: https://github.com/Serendipity36/SpringCloud-Config.git #github仓库上面的git仓库名字 ##搜索目录 search-paths: - SpringCloud-Config #读取分支 label: master #rabbitmq相关配置 15672是web管理界面的端口；5672是MQ访问的端口 rabbitmq: host: localhost prot: 5672 username: guest password: guest eureka: client: service-url: defaultZone: http://localhost:7001/eureka #注册进eureka #rabbitmq相关配置，暴露bus刷新配置的端点 management: endpoint: endpoints: web: exposure: include: 'bus-refresh' 4.给cloud-config-client3355和cloud-config-client3366客户端添加消息总线支持 pom文件添加 &lt;!--添加消息总线RabbitMQ支持--> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-bus-amqp&lt;/artifactId> &lt;/dependency> 5.测试 修改github上版本号 发送post请求：curl -X POST “http://localhost:3344/actuator/bus-refresh&quot; 一次发送，处处生效 SpringCloud Bus动态刷新定点通知 指定某一个实例生效而不是全部 公式：http://localhost:3344/actuator/bus-refresh/{destination} 只刷新3355，不刷新3366： curl -X POST “http://localhost:3344/actuator/bus-refresh/config-client:3355&quot;","categories":[{"name":"SpringCloud学习","slug":"SpringCloud学习","permalink":"https://serendipity36.github.io/categories/SpringCloud%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"SpringCloud之分布式配置中心（尚硅谷）","slug":"SpringCloud之分布式配置中心(尚硅谷)","date":"2020-08-04T06:23:30.000Z","updated":"2020-08-05T05:32:20.679Z","comments":true,"path":"2020/08/04/SpringCloud之分布式配置中心(尚硅谷)/","link":"","permalink":"https://serendipity36.github.io/2020/08/04/SpringCloud%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83(%E5%B0%9A%E7%A1%85%E8%B0%B7)/","excerpt":"","text":"SpringCloud Config分布式配置中心SpringCloud Config概述分布式系统面临的配置问题 微服务意味着要将单体应用中的业务拆分成一个个子服务, 每个服务的粒度相对较小，因此系统中会出现大量的服务。于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。 SpringCloud Config简述 SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持,配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。 SpringCloud Config分为服务端和客户端两部分。 服务端也称为分布式配置中心，他是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口。 客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息，配置服务器默认采用git来存储配置信息，这样有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。 SpringCloud Config作用1.集中管理配置文件 2.不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release 3.运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件,服务会向配置中心统一一拉取配置自己的信息 4.当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置 5.将配置信息以REST接口的形式暴露 Config服务端配置与测试1.用自己的账号在GitHub上新建一个名为SpringCloud-Config的新Repository 2.由上一步获得刚新建的git地址：&#x67;&#105;&#116;&#x40;&#103;&#105;&#x74;&#104;&#117;&#x62;&#46;&#x63;&#111;&#109;:Serendipity36/SpringCloud-Config.git 3.本地硬盘目录上新建git仓库并clone：git命令 git clone &#x67;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#117;&#x62;&#x2e;&#x63;&#x6f;&#x6d;:Serendipity36/SpringCloud-Config.git 4.新建Module模块cloud-config-center3344 pom.xml文件： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;parent> &lt;artifactId>cloud2020&lt;/artifactId> &lt;groupId>com.sunqs.springcloud&lt;/groupId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;/parent> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;artifactId>cloud-config-center3344&lt;/artifactId> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-config-server&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-actuator&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-devtools&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;optional>true&lt;/optional> &lt;/dependency> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;optional>true&lt;/optional> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/project> application.yml文件: server: port: 3344 spring: application: name: cloud-config-center cloud: config: server: git: uri: https://github.com/Serendipity36/SpringCloud-Config.git #github仓库上面的git仓库名字 ##搜索目录 search-paths: - SpringCloud-Config #读取分支 label: master eureka: client: service-url: defaultZone: http://localhost:7001/eureka #注册进eureka 5.主启动类 @SpringBootApplication @EnableConfigServer public class ConfigCenterMain3344 &amp;#123; public static void main(String[] args) &amp;#123; SpringApplication.run(ConfigCenterMain3344.class,args); &amp;#125; &amp;#125; 6.修改hosts映射 增加 127.0.0.1 config-3344.com 7.测试通过Config微服务是否可以从GitHub上获取配置内容 启动微服务，访问 8.总结 （转自https://blog.csdn.net/kingtok/article/details/105178367） 成功实现了用SpringCloud Config通过GitHub获取配置信息 Config客户端配置与测试1.新建Module:cloud-config-client3355 pom.xml文件： &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;parent> &lt;artifactId>cloud2020&lt;/artifactId> &lt;groupId>com.sunqs.springcloud&lt;/groupId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;/parent> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;artifactId>cloud-config-client3355&lt;/artifactId> &lt;dependencies> &lt;!--不带server了，说明是客户端--> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-config&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-actuator&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-devtools&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;optional>true&lt;/optional> &lt;/dependency> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;optional>true&lt;/optional> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/project> bootstrap.yml文件： server: port: 3355 spring: application: name: config-client cloud: #Config客户端配置 config: label: master #分支名称 name: config #配置文件名称 profile: dev #读取后缀名称 上述3个综合：master分支上config-dev.yml的配置文件被读取 http://config-3344.com:3344/master/config-dev.yml uri: http://localhost:3344 #配置中心地址 表示通过这个服务端访问 #服务注册到eureka地址 eureka: client: register-with-eureka: true service-url: defaultZone: http://localhost:7001/eureka 2.主启动类 @SpringBootApplication @EnableEurekaClient public class ConfigClient3355 &amp;#123; public static void main(String[] args) &amp;#123; SpringApplication.run(ConfigClient3355.class,args); &amp;#125; &amp;#125; 4.业务类 @RestController public class ConfigClientController &amp;#123; @Value(\"$&amp;#123;config.info&amp;#125;\") private String configInfo; @GetMapping(\"/configInfo\") public String getConfigInfo()&amp;#123; return configInfo; &amp;#125; &amp;#125; 5.测试访问http://localhost:3355/configInfo成功 Config客户端之动态刷新 避免每次更新配置都要重启客户端微服务3355 修改步骤1.pom引入actuator监控 2.修改yml文件，暴露监控端口，添加如下配置 #暴露监控端点 management: endpoints: web: exposure: include: \"*\" 3.业务类添加@RefreshScope注解 4.测试发现不重启还是修改之前的数据，这时就需要向3355发送一条post请求激活动态配置 curl -X POST “http://localhost:3355/actuator/refresh&quot; 再测试发现生效了 假如有多个微服务，每个微服务都要执行一次post请求，手动刷新吗？ 可否广播，一次通知，处处生效？ 想大范围的自动刷新 见下一章SpringCloud Bus消息总线","categories":[{"name":"SpringCloud学习","slug":"SpringCloud学习","permalink":"https://serendipity36.github.io/categories/SpringCloud%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"SpringCloud之服务网关（尚硅谷）","slug":"SpringCloud之服务网关(尚硅谷)","date":"2020-08-03T03:01:49.000Z","updated":"2020-08-05T01:30:31.393Z","comments":true,"path":"2020/08/03/SpringCloud之服务网关(尚硅谷)/","link":"","permalink":"https://serendipity36.github.io/2020/08/03/SpringCloud%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3(%E5%B0%9A%E7%A1%85%E8%B0%B7)/","excerpt":"","text":"Gateway新一代网关什么是Gateway网关？1.Gateway是在Spring生态系统之上构建的API网关服务,基于Spring 5,Spring Boot 2和Project Reactor等技术。 2.Gateway旨在提供一 种简单而有效的方式来对API进行路由，以吸提供- 些强大的过滤器功能， 例如:熔断、限流、重试等 3.SpringCloud Gateway是Spring Cloud的一个全新项目,纡Spring 5.0+ Spring Boot 2.0和Project Reactor等技术开发的网关,它旨在为微服务架构提供一种简单有效的统一 的API路由管理方式。 4.SpringCloud Gateway作为Spring Cloud生态系统中的网关，目标是替代Zuul,在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 1.x非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty 5.SpringCloud Gateway的目标提供统一的路由方式且基 于Filter 链的方式提供了网关基本的功能，例如:安全，监控/指标, 和限流。 SpringCloud Gateway的特性1.基于Spring Framework 5, Project Reactor和Spring Boot 2.0进行构建; 2.动态路由:能够匹配任何请求属性; 3.可以对路由指定Predicate (断言)和Filter (过滤器) ; 4.集成Hystrix的断路器功能; 5.集成Spring Cloud服务发现功能; 6.易于编写的Predicate (断言)和Filter (过滤器) ; 7.请求限流功能; 8.支持路径重写。 Gateway三大核心概念 Route路由：路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由。 Predicate断言：参考的是java8的java.util.function.Predicate。开发人员可以匹配HTTP请求中的所有内容（例如请求头或请求参数），如果请求与断言相匹配则进行路由。 Filter过滤：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。 web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后，进行一些精细化控制。 predicate就是我们的匹配条件；而filter，就可以理解为一个无所不能的拦截器。而有了这两个元素，再加上目标uri，就可以实现一个具体的路由了。 Gateway工作流程 核心逻辑：路由转发+执行过滤器链 入门配置1.新建module：cloud-gateway-gateway9527 2.改pom文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;parent> &lt;artifactId>cloud2020&lt;/artifactId> &lt;groupId>com.sunqs.springcloud&lt;/groupId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;/parent> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;artifactId>cloud-gateway-gateway9527&lt;/artifactId> &lt;dependencies> &lt;!--gateway--> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-gateway&lt;/artifactId> &lt;/dependency> &lt;!--eureka client--> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId> &lt;/dependency> &lt;!--引入自定义的api通用包，可使用Payment支付Entity--> &lt;dependency> &lt;groupId>com.aiguigu.springcloud&lt;/groupId> &lt;artifactId>cloud-api-commons&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;scope>compile&lt;/scope> &lt;/dependency> &lt;!--一般基础配置类--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-devtools&lt;/artifactId> &lt;scope>runtime&lt;/scope> &lt;optional>true&lt;/optional> &lt;/dependency> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;optional>true&lt;/optional> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-test&lt;/artifactId> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/project> 3.写yml server: port: 9527 spring: application: name: cloud-gateway cloud: gateway: routes: - id: payment_routh #payment_routh #路由的ID，没有固定规则但要求唯一，简易配合服务名 uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** #断言，路径相匹配的进行路由 - id: payment_routh2 #payment_routh #路由的ID，没有固定规则但要求唯一，简易配合服务名 uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/lb/** #断言，路径相匹配的进行路由 eureka: instance: hostname: cloud-gateway-service client: service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka 4.业务类：无 5.主启动类：GateWayMain9527 @SpringBootApplication @EnableEurekaClient public class GateWayMain9527 &amp;#123; public static void main(String[] args) &amp;#123; SpringApplication.run(GateWayMain9527.class,args); &amp;#125; &amp;#125; 6.测试：http://localhost:8001/payment/get/31与http://localhost:9527/payment/get/31 都可以访问到。 7:gateway网关路由有两种配置方式 在配置文件yml中配置； 代码中注入RouteLocator的Bean： @Configuration public class GatewayConfig &amp;#123; @Bean public RouteLocator customRouteLocator(RouteLocatorBuilder routeLocatorBuilder)&amp;#123; RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes(); routes.route(\"path_route_atguigu\", r -> r.path(\"/guonei\") .uri(\"http://news.baidu.com/guonei\")).build(); return routes.build(); &amp;#125; &amp;#125; 如果要访问 http://news.baidu.com/guonei 这个网站,配置路由规则为http://localhost:9527/guonei就可以访问到 通过微服务名实现动态路由 pom文件修改如下 server: port: 9527 spring: application: name: cloud-gateway cloud: gateway: discovery: locator: enabled: true #开启从注册中心动态动态创建路由的功能,利用微服务名进行路由 routes: - id: payment_routh #payment_routh #路由的ID，没有固定规则但要求唯一，简易配合服务名 uri: lb://cloud-payment-service # uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** #断言，路径相匹配的进行路由 - id: payment_routh2 #payment_routh #路由的ID，没有固定规则但要求唯一，简易配合服务名 uri: lb://cloud-payment-service # uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/lb/** #断言，路径相匹配的进行路由 eureka: instance: hostname: cloud-gateway-service client: fetch-registry: true register-with-eureka: true service-url: #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址 # defaultZone: http://eureka7002.com:7002/eureka/ # 单机版eureka defaultZone: http://eureka7001.com:7001/eureka/ Predicate的使用常用的Route Predicate After Route Predicate：- After=2020-08-04T08:54:04.768+08:00[Asia/Shanghai] Before Route Predicate：- Before=2020-08-04T08:54:04.768+08:00[Asia/Shanghai] Between Route Predicate：- Between=2020-08-04T08:54:04.768+08:00[Asia/Shanghai],2020-09-04T08:54:04.768+08:00[Asia/Shanghai] Cookie Route Predicate：- Cookie=username,zzyy Header Route Predicate：- Header=X-Request-Id,\\d+ Host Route Predicate Method Route Predicate Path Route Predicate Query Route Predicate 时间断言格式的获取public static void main(String[] args) &amp;#123; ZonedDateTime zdt = ZonedDateTime.now(); System.out.println(zdt); &amp;#125; 2020-08-04T08:54:04.768+08:00[Asia/Shanghai] 总结Predicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理。 Filter的使用Gateway Filter是什么路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。 Spring Cloud Gateway 内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生。 生命周期：pre，post 种类：GatewayFilter(31种),GlobalFilter(十种) 自定义过滤器1.创建Gateway配置类 @Configuration @Slf4j @Order(0) public class MyLogGatewayFilter implements GlobalFilter, Ordered &amp;#123; @Override public Mono&lt;Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) &amp;#123; log.info(\"******come in MyLogGatewayFilter: \" + new Date()); String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\"); if (uname == null) &amp;#123; log.info(\"******用户名为null，非法用户，😿\"); exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE); return exchange.getResponse().setComplete(); &amp;#125; return chain.filter(exchange); &amp;#125; @Override public int getOrder() &amp;#123; return 0; &amp;#125; &amp;#125; // @Override 实现上面@Order(0)注解就可以不用实现接口 // public int getOrder() &amp;#123; // return 0; // &amp;#125; 可以写多个Filter进行过滤，传回过滤链就行。","categories":[{"name":"SpringCloud学习","slug":"SpringCloud学习","permalink":"https://serendipity36.github.io/categories/SpringCloud%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-08-03T02:57:46.437Z","updated":"2020-08-03T02:57:46.437Z","comments":true,"path":"2020/08/03/hello-world/","link":"","permalink":"https://serendipity36.github.io/2020/08/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"SpringCloud学习","slug":"SpringCloud学习","permalink":"https://serendipity36.github.io/categories/SpringCloud%E5%AD%A6%E4%B9%A0/"}],"tags":[]}